---
layout  : wiki
title   : HikariCP
summary : 
date    : 2022-05-02 15:02:32 +0900
updated : 2022-05-02 15:12:24 +0900
tag     : hikaricp
toc     : true
comment : true
public  : true
parent  : [[/database]]
latex   : true
---
* TOC
{:toc}

# HikariCP

## What is HikariCP

> 光 HikariCP・A solid, high-performance, JDBC connection pool at last.

HikariCP 는 고성능 JDBC Connection Pool 이다. 2012년경 [Brett Wooldridge](https://github.com/brettwooldridge) 가 
개발한 매우 가볍고(약 130Kb) 번개처럼 빠른 zero-overhead JDBC 연결 풀링 프레임워크이다.

> "Simplicity is prerequisite for reliability." - Edsger Dijkstra

## Down the Rabbit hole

HikariCP 는 어떤 방식으로 성능 최적화를 이끌어낼까?

### getConnection()

HikariCP 는 getConnection 의 수가 다른 JDBC 에 비해서 적다. 

### FastList

전체 성능을 향상 시키기 위한 다양한 미세 최적화들이 존재한다. FastList 는 그 중 하나이다.

- 한 가지 중요하지 않은(성능 면에서) 최적화는 열린 인스턴스를 추적 하는 데 사용되는 `ArrayList<Statement>` 인스턴스 의 사용을 제거하는 것이었다. 닫히면 이 컬렉션에서 제거되어야 하고 닫힐 때 컬렉션을 반복하고 열려 있는 모든 인스턴스를 닫고 마지막으로 컬렉션을 지워야 한다.
- 자바의 ArrayList 의 remove() 는 head to tail 로 스캔하지만, JDBC 프로그래밍의 일반적인 패턴은 사용 직후 문을 닫거나 열기의 역순으로 수행하는 것이 효과적이다.
- 따라서 범위 검사를 제거하고 꼬리에서 머리까지 제거 스캔을 수행 하는 사용자 정의 클래스(FastList)로 대체되었다.

### ConcurrentBag

- HikariCP 에는 ConcurrentBag 라는 사용자 지정 잠금 없는 컬렉션이 포함되어 있다. 아이디어는 C# .NET ConcurrentBag 클래스에서 차용했지만 내부 구현은 상당히 다르다. 
- ConcurrentBag 는 다음을 제공한다.
  - A lock-free design
  - ThreadLocal caching
  - Queue-stealing
  - Direct hand-off optimizations
  - ...resulting in a high degree of concurrency, extremely low latency, and minimized occurrences of false-sharing

### Invocation: invokevirtual vs invokestatic

- __invokevirtual__
  - Connection, Statement 및 ResultSet 인스턴스에 대한 프록시를 생성하기 위해 HikariCP 는 초기에 ConnectionProxy 정적 필드(PROXY_FACTORY)에 유지되는 싱글톤 팩토리를 사용했었다.
  - ```java
    public final PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return PROXY_FACTORY.getProxyPreparedStatement(this, delegate.prepareStatement(sql, columnNames));
    }
    ```
  - Using the original singleton factory, the generated bytecode looked like this:
  - ```java
    public final java.sql.PreparedStatement prepareStatement(java.lang.String, java.lang.String[]) throws java.sql.SQLException;
    flags: ACC_PRIVATE, ACC_FINAL
    Code:
      stack=5, locals=3, args_size=3
         0: getstatic     #59                 // Field PROXY_FACTORY:Lcom/zaxxer/hikari/proxy/ProxyFactory;
         3: aload_0
         4: aload_0
         5: getfield      #3                  // Field delegate:Ljava/sql/Connection;
         8: aload_1
         9: aload_2
        10: invokeinterface #74,  3           // InterfaceMethod java/sql/Connection.prepareStatement:(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement;
        15: invokevirtual #69                 // Method com/zaxxer/hikari/proxy/ProxyFactory.getProxyPreparedStatement:(Lcom/zaxxer/hikari/proxy/ConnectionProxy;Ljava/sql/PreparedStatement;)Ljava/sql/PreparedStatement;
        18: return
    ```
- __invokestatic__
  - We eliminated the singleton factory (which was generated by Javassist) and replaced it with a final class having static methods (whose bodies are generated by Javassist). The Java code became:
  - ```java
    public final PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
      return ProxyFactory.getProxyPreparedStatement(this, delegate.prepareStatement(sql, columnNames));
    }
    ```
  - Where getProxyPreparedStatement() is a static method defined in the ProxyFactory class. The resulting bytecode is:
  - ```java
    private final java.sql.PreparedStatement prepareStatement(java.lang.String, java.lang.String[]) throws java.sql.SQLException;
    flags: ACC_PRIVATE, ACC_FINAL
    Code:
      stack=4, locals=3, args_size=3
         0: aload_0
         1: aload_0
         2: getfield      #3                  // Field delegate:Ljava/sql/Connection;
         5: aload_1
         6: aload_2
         7: invokeinterface #72,  3           // InterfaceMethod java/sql/Connection.prepareStatement:(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement;
        12: invokestatic  #67                 // Method com/zaxxer/hikari/proxy/ProxyFactory.getProxyPreparedStatement:(Lcom/zaxxer/hikari/proxy/ConnectionProxy;Ljava/sql/PreparedStatement;)Ljava/sql/PreparedStatement;
        15: areturn
    ```
- __What is differences__
  - getStatic() 호출이 필요 없어짐
  - The invokevirtual call is replaced with a invokestatic call that is more easily optimized by the JVM.
  - stack size 가 5개에서 4개로 줄어듦. 전체적으로 이 변경으로 인해 스택에서 정적 필드 액세스, 푸시 및 팝이 제거되었으며 호출 사이트가 변경되지 않도록 보장 되므로 JIT 에서 호출을 더 쉽게 최적화할 수 있다.

## About Pool sizing

## With Spring Boot

Spring Boot 는 기존에 tomcat-jdbc 를 기본 Datasource 로 제공했었는데 2.0부터 HikariCP가 기본으로 변경되었다.


## Links

- [HikariCP](https://github.com/brettwooldridge/HikariCP)
- [Down the Rabbit Hole](https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole)
- [Using HikariCP connection pool](https://zetcode.com/articles/hikaricp/#:~:text=HikariCP%20is%20solid%20high%2Dperformance,reduce%20the%20overall%20resource%20usage.)
- [HikariCP BenchMark](https://github.com/brettwooldridge/HikariCP/issues/7)
- [About-Pool-Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)
- [Spring-Boot-2.0-Migration-Guide configuring-a-datasource](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#configuring-a-datasource)
- [Spring Boot 와 Hikaricp 연동하기](https://jojoldu.tistory.com/296)