---
layout  : wiki
title   : Fundamental Object-Oriented Programming
summary : 
date    : 2022-04-29 15:02:32 +0900
updated : 2022-04-29 15:12:24 +0900
tag     : oop
toc     : true
comment : true
public  : true
parent  : [[/oop]]
latex   : true
favorite: true
---
* TOC
{:toc}

# Object-Oriented Programming

## OO

> OO design is more important than any particular implementation technology (such as J2EE, or even Java). And now important than even Spring or Hibernate. Good Programming practices and sound OO design underpin good J2EE applications. Bad Java code is bad J2EE code. - Rod Johnson.

## 객체지향의 목표

> 객체지향의 목표는 실세계를 모방하는 것이 아니라, 새로운 세계를 창조하는 것이다.

## 객체지향의 본질

> 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
> 
> 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
> 
> 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.
> 
> 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.

## 객체지향 설계 핵심

> 객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다.

## 역할, 책임, 협력

### 역할

> 카페테리아에서는 캐시어, 손님, 바리스타라는 역할이 존재한다. 그리고, 손님이 주문한 커피를 제조하여 제공하는 협력을한다. 역할은 어떤 협력에 참여하는 특정한 사람이 협력 안에서 차지하는 책임이나 임무를 의미한다.

역할은 `책임(responsibility)`을 내포한다. 역할을 아래와 같은 특징을 지닌다.

- 여러 사람이 동일한 역할을 수행할 수 있다.
- 역할은 대체 가능성을 의미한다.
- 책임을 수행하는 방법은 자율적으로 선택할 수 있다.
- 한 사람이 동시에 여러 역할을 수행할 수 있다.

### 책임

> 객체지향 설계라는 예술은 적절한 객체에게 적절한 책임을 할당하는 것에서 시작된다. __책임은 객체지향 설계의 품질을 결정하는 가장 중요한 요소이다.__ 책임이 불분명한 객체는 애플리케이션의 미래 역시 불분명하게 만든다. 얼마나 적절한 책임을 선택하느냐가 애플리케이션의 아름다움을 결정한다.

### 협력

> 협력의 핵심은 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성하는 것이다.

## 객체

> 객체지향 애플리케이션의 윤곽을 결정하는 것은 역할, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체이다.
>
> 객체지향 애플리케이션의 아름다움을 결정하는 것이 협력이라면 협력이 얼마나 조화를 이루는지를 결정하는 것이 객체다. 결국 협력의 품질을 결정하는 것은 객체의 품질이다.
>
> 객체는 `상태(state)`와 `행동(behavior)`을 함께 지닌 실체이다.

객체는 다음과 같은 두 가지 덕목을 갖춰야 한다.

- 객체는 충분히 협력적이어야 한다.
- 객체는 충분히 자율적이어야 한다.

> 객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나온다. 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며, 객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통 해야 한다.
>
> 객체는 다른 객체가 무엇(what)을 수행하는지는 알 수 있지만, 어떻게(how) 수행하는지에 대해서는 알 수 없다.

### 협력적

> 협력적이라는 말은 다른 객체의 명령에 따라 행동하는 수동적인 존재를 의미하는 것이 아니다.

### 자율적

> 자율적이라는 말은 자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제하는 것을 의미한다. 
>
> 외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘이다. 이것은 캡슐화(encapsulation)라는 개념과도 깊이 관련돼 있다.
>
> 객체는 자율적인 존재라는 점을 명심하라. 객체지향의 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없다. 자율적인 객체는 스스로 자신의 상태를 책임져야 한다. 외부의 객체가 직접적으로 객체의 상태를 주무를 수 없다면 간접적으로 객체의 상태를 변경하거나 조회할 수 있는 방법이 필요하다.
> 
> 객체의 상태를 변경하는 것은 객체의 자발적인 행동 뿐이다.

## 메시지 

> 객체지향의 세계에서는 오직 한 가지 의사소통 수단만이 존재한다. 이를 메시지라고 한다. 한 객체가 다른 객체에게 요청하는 것을 메시지를 전송한다고 말하고 다른 객체로부터 요청을 받는 것을 메시지를 수신한다고 말한다.
>
> 메시지를 전송하는 객체를 `송신자(sender)`라고 부르고 메시지를 수신하는 객체를 `수신자(receiver)`라고 부른다.
>
> 객체가 수신된 메시지를 처리하는 방법을 `메서드(method)`라고 한다.

## 상태와 행동

> 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 갑소가 다른 객체를 참조하는 링크로 구분할 수 있다.
> 
> 행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.

- 객체의 행동은 상태에 영향을 받는다.
- 객체의 행동은 상태를 변경시킨다.

## 식별자

> 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정 프로퍼티가 객체 안에 존재한다는 것을 의미한다. 이 프로퍼티를 식별자라고 한다.
>
> 값(value)은 숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링한다. 흔히 값의 상태는 변하지 않기 때문에 불변 상태(immutable state)를 가진다고 말한다.
> 
> 값이 같은지 여부는 상태가 같은지를 이용해 판단한다. 이처럼 상태를 이용해 두 값이 같은지를 판단할 수 있는 성질을 동등성(equality)이라고 한다.
>
> 두 객체의 상태가 다르더라도 식별자가 같다면 두 객체를 같은 객체로 판단할 수 있다. 이처럼 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성(identical)이라고 한다.
> 
> 식별자란 어떤 객체를 다른 객체와 구분하는데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.

## 행동이 상태를 결정한다 

> 상태를 먼저 결정할 경우의 단점은 다음과 같다. 
>
> 캡슐화가 저해된다. 객체를 협력자가 아닌 고립된 섬으로 만든다. 객체의 재사용성이 저하된다.
> 
> 객체의 적합성을 결정하는 것은 상태가 아닌 객체의 행동이다. 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다. 따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.

## 추상화

> 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
 
복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다.

- 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

> 객체지향 패러다임은 객체라는 추상화를 통해 현실의 복잡성을 극복한다.

## 타입

> 동일한 타입에 속한다라는 의미는, 동일한 책임을 수행한다는 말과 동일하다. 그 객체가 어떤 데이터를 가지고 있는지는 우리의 관심사가 아니다.
> 
> 객체의 타입을 결정하는 것은 객체의 행동뿐이다. 객체가 어떤 데이터를 보유하고 있는지는 타입을 결정하는 데 아무런 영향도 미치지 않는다.
>
> 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 동일한 행동이란 동일한 책임을 의미하며, 동일한 메시지 수신을 의미한다. 이것은 다형성에 의미를 부여한다. 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다.
>
> 타입의 목적은 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵기 때문이다.
> 
> 그래서 결국 타입은 추상화다. 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법인 것이다.

## 책임 주도 설계

> 객체지향 설계는 적절한 책임을 객체에게 할당하면서 메시지를 기반으로 협력하는 객체들의 관계를 발견하는 과정이다. 이처럼 책임을 완수하기 위해 협력하는 객체들을 이용해 시스템을 설계하는 방법을 책임-주도 설계라고 한다.
> 
> 책임 주도 설계의 기본 아이디어는 객체들 간에 주고받는 메시지를 기반으로 적절한 역할과 책임, 협력을 발견하는 것이다.

### What/Who Cycle

> 책임 주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다.
> 이 과정을 흔히 What/Who 사이클이라고 한다.
> 
> What/Who 사이클이라는 용어가 의미하는 것은 객체 사이의 협력 관계를 설계하기 위해서는 먼저 어떤 행위(what)를 수행할 것인지를 결정한 후에 누가(who) 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 어떤 행위가 바로 메시지다.

### Law Of Demeter

> 메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식은 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게 한다. 이 스타일을 `Tell Don't ask` or `Law Of Demeter(데메테르 법칙)`이라고 한다.
> 
> 객체는 다른 객체의 상태를 묻지 말아야 한다. 객체가 다른 객체의 상태를 묻는다는 것은 메시지를 전송하기 이전에 객체가 가져야 하는 상태에 관해 너무 많이 고민하고 있다는 증거다.
> 
> 결과적으로 `묻지 말고 시켜라` 스타일은 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 주기 때문에 설계를 유연하게 만든다.
> 
> 메시지를 믿어라. 그러면 자율적인 책임은 저절로 따라올 것이다.

## 디자인 패턴

> 디자인 패턴은 책임 주도 설계의 결과를 표현한다. 패턴은 모범이 되는 설계다. 패턴은 특정한 상황에서 설계를 돕기 위해 모방하고 수정할 수 있는 과거의 설계 경험이다.
> 
> 일반적으로 디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의된다. 따라서 해결하려고 하는 문제가 무엇인지를 명확하게 서술하고, 패턴을 적용할 수 있는 상황과 적용할 수 없는 상황을 함께 설명한다. 패턴은 반복해서 일어나는 특정한 상황에서 어떤 설계가 왜(why) 더 효과적인지에 대한 이유를 설명한다.

## 테스트 주도 개발

> 테스트 주도 개발은 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하라고 충고한다. 그러나 이 같은 종류의 충고는 역할, 책임, 협력의 관점에서 객체를 바라보지 않을 경우 무의미하다.
> 
> 책임과 협력의 관점에서 객체를 바라보는 훈련이 부족하면 테스트 주도 개발이 어려울 수 있다. 테스트 주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드 형태로 작성하는 것이다.
> 
> 테스트 주도 개발은 책임 주도 설계의 기본 개념을 따른다.
> 
> 테스트 주도 개발은 책임 주도 설계를 통해 도달해야 하는 목적지를 테스트라는 안전장치를 통해 좀 더 빠르고 견고한 방법으로 도달할 수 있도록 해주는 최상의 설계 프랙티스다.
> 
> 테스트 주도 개발은 책임 주도 설계의 기본 개념과 다양한 원칙과 프랙티스, 패턴을 종합적으로 이해하고 좋은 설계에 대한 감각과 경험을 길러야만 적용할 수 있는 설계 기법이다. 역할, 책임, 협력에 집중하고 객체지향의 원칙을 적용하려는 깊이 있는 고민과 노력을 통해서만 테스트 주도 개발의 혜택을 누릴 수 있다.

## 다형성

> 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다.
> 
> 다형성은 객체들의 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만든다. 다형성을 사용하면 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다. 객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들 수 있기 때문이다.

## 인터페이스

> 일반적으로 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치를 의미한다.

일반적으로 인터페이스는 다음과 같은 세 가지 특징을 지닌다.

- 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달 할 수 있다.
- 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
- 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용 할 수 있다.

> 메시지가 인터페이스를 결정한다. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이다. 따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스의 모양을 빚는다.

### 인터페이스와 구현의 분리 원칙

> 인터페이스와 구현의 분리 원칙(separation of interface and implementation)은 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체의 내무에 숨겨지는 구현을 명확하게 분리해서 고려해야 한다는 것을 의미한다. 
> 
> 결론적으로 객체 설계의 핵심은 객체를 두 개의 분리된 요소로 분할해 설계하는 것이다. 그것은 바로 외부에 공개되는 인터페이스와 내부에 감춰지는 구현이다.

## 캡슐화

> 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 캡슐화라고 한다. 캡슐화를 `정보 은닉(information hiding)`이라고 부르기도 한다.

캡슐화는 두 가지 관점에서 사용된다.

- __상태와 행위의 캡슐화__
  - 객체는 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야만 하는 행위만 골라 공용 인터페이스를 통해 노출한다.
- __사적인 비밀의 캡슐화__
  - 캡슐화를 통해 변경이 빈번하게 일어나는 불안정한 비밀을 안정적인 인터페이스 뒤로 숨길 수 있다. 일반적으로 불안정한 비밀은 구현과 관련된 세부 사항을 의미한다.

## 도메인

> 객체지향을 사용하면 사용자들이 이해하고 있는 도메인 구조와 최대한 유사하게 코드를 구조화할 수 있다. 결과적으로 객체지향을 이용하면 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습을 유지하도록 만드는 것이 가능하다. 객체지향의 이러한 특징을 연결완전성 또는 표현적 차이라고 부른다.

## References

- 객체지향의 사실과 오해 / 조영호 저 / 위키 북스