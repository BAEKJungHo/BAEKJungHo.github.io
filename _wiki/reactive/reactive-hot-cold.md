---
layout  : wiki
title   : Hot and Cold publishers
summary : 
date    : 2023-02-15 21:28:32 +0900
updated : 2023-02-15 22:15:24 +0900
tag     : reactive
toc     : true
comment : true
public  : true
parent  : [[/reactive]]
latex   : true
---
* TOC
{:toc}

## Hot and Cold publishers

l Flux (and Mono) are the same: They all represent an asynchronous sequence of data, and nothing happens before you subscribe.

__Cold  publishers.__ They generate data anew for each subscription. If no subscription is created, data never gets generated.

__Hot publishers__, on the other hand, do not depend on any number of subscribers. They might start publishing data right away and would continue doing so whenever a new Subscriber comes in (in which case, the subscriber would see only new elements emitted after it subscribed). For hot publishers, something does indeed happen before you subscribe.

In Spring WebFlux, a Publisher can be either a hot or a cold Publisher. Here are some examples of both:

__Hot Publisher example:__

```java
Flux<Long> hotPublisher = Flux.interval(Duration.ofMillis(500));
hotPublisher.subscribe(System.out::println);

// This will start emitting data immediately, even if no one is subscribed yet.
```

In this example, we're creating a Flux that emits a value every 500 milliseconds using the interval method. We subscribe to the Flux using the subscribe method, and we print the emitted values to the console using a lambda function. Since we didn't specify a number of items to emit, the Flux will keep emitting values until it's cancelled.

The hotPublisher is a hot Publisher because it emits data whether or not there are any subscribers. In this case, it starts emitting data immediately, even before the subscribe method is called. When a subscriber does subscribe, it will receive the values emitted by the hotPublisher starting from the current point in time.

__Cold Publisher example:__

```java
Mono<String> coldPublisher = Mono.defer(() -> Mono.just(UUID.randomUUID().toString()));
coldPublisher.subscribe(System.out::println);

// This will only emit data when someone subscribes.
```

In this example, we're creating a Mono that emits a random UUID using the defer method. We subscribe to the Mono using the subscribe method, and we print the emitted value to the console using a lambda function.

The coldPublisher is a cold Publisher because it doesn't emit data until there's a subscriber. When a subscriber does subscribe, it will receive a new UUID generated by the Mono every time, instead of sharing the same value with other subscribers.

Note that in both examples, we're subscribing to the Publisher using the subscribe method. In a real application, you would typically use a Subscriber implementation to subscribe to a Publisher, which gives you more control over how you handle the emitted values.

## Links

- [Hot Versus Cold](https://projectreactor.io/docs/core/release/reference/#reactor.hotCold)

## References

- Reactive Spring / JOSH LONG / STARBUXMAN